/* Copyright (C) 2022, Nikolai Wuttke. All rights reserved.
 *
 * This project is based on disassembly of NUKEM2.EXE from the game
 * Duke Nukem II, Copyright (C) 1993 Apogee Software, Ltd.
 *
 * Some parts of the code are based on or have been adapted from the Cosmore
 * project, Copyright (c) 2020-2022 Scott Smitelli.
 * See LICENSE_Cosmore file at the root of the repository, or refer to
 * https://github.com/smitelli/cosmore/blob/master/LICENSE.
 *
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */


/*******************************************************************************

Translation unit 2

Includes various other files as a Unity build, and contains a few random
functions that don't really fit anywhere else.

*******************************************************************************/


#include "actors.h"
#include "basicsnd.h"
#include "common.h"
#include "digisnd.h"
#include "gamedefs.h"
#include "gfx.h"
#include "lvlhead.h"
#include "scancode.h"
#include "sounds.h"

#include <alloc.h>
#include <dos.h>
#include <stdio.h>
#include <stdlib.h>


// Menu IDs as used in the script files shipping with the game
#define MT_SKILL_SELECT    0
#define MT_MAIN_MENU       1
#define MT_EPISODE_SELECT  2
#define MT_OPTIONS         3
#define MT_RESTORE_GAME    5
#define MT_SAVE_GAME       6
#define MT_KEY_CONFIG      7
#define MT_GAME_SPEED      8
#define MT_DBG_WPN_SELECT 10
#define MT_DBG_LVL_WARP   11


// [NOTE] decl mismatch
bool pascal IsSaveSlotEmpty(byte index);


#include "vars.c"


/* Actor id to frame list index map
 *
 * Actors can have multiple animation frames. The number of frames depends on
 * the actor. When laying out all animation frames of all actors in sequence, we
 * need a way to know where in that sequence we can find the frames for a
 * specific actor. This is what this array is for. For each actor id, it
 * contains the starting index of that actor's frames within the flat list of
 * all actors' frames.  This is hardcoded, and needs to be adjusted when
 * changing the number of frames an actor has.
 *
 * [NOTE] It would be quite easy to fill this array at runtime, when loading the
 * actor info. That would make it easier to modify the actor data. Then again,
 * most of the actor logic expects a specific number of animation frames to
 * exist, so changing the data requires changes to the code either way.
 *
 * It's possible that this array was generated by a tool in the original code.
 */
word FRAME_INDEX_MAP[] = {
     0,   12,   18,   26,   33,   37,   76,  115,  116,  117,  118,  119,  123,
   124,  125,  127,  128,  129,  130,  131,  132,  133,  134,  135,  136,  137,
   138,  139,  140,  149,  216,  217,  220,  223,  224,  225,  226,  227,  228,
   229,  230,  238,  246,  254,  262,  263,  267,  271,  275,  279,  288,  288,
   292,  293,  297,  300,  303,  306,  309,  311,  317,  318,  319,  322,  325,
   326,  337,  341,  351,  360,  367,  378,  386,  387,  388,  389,  397,  400,
   403,  421,  429,  437,  448,  448,  448,  452,  453,  454,  456,  458,  458,
   458,  461,  467,  472,  480,  489,  493,  496,  506,  516,  517,  523,  524,
   524,  524,  524,  525,  526,  527,  528,  529,  531,  533,  535,  539,  544,
   545,  547,  550,  555,  559,  560,  566,  574,  582,  590,  598,  606,  615,
   616,  620,  628,  631,  640,  648,  648,  649,  650,  651,  652,  653,  654,
   655,  656,  657,  659,  660,  661,  662,  664,  668,  676,  677,  678,  694,
   695,  696,  697,  698,  714,  715,  716,  717,  718,  719,  723,  727,  731,
   739,  740,  741,  741,  742,  743,  744,  745,  751,  752,  753,  754,  755,
   756,  757,  758,  759,  761,  762,  763,  767,  773,  779,  783,  784,  785,
   786,  787,  788,  789,  790,  791,  795,  795,  803,  811,  812,  813,  814,
   815,  817,  823,  826,  827,  831,  835,  845,  852,  858,  858,  858,  860,
   867,  867,  871,  875,  879,  883,  884,  885,  888,  891,  894,  900,  901,
   901,  901,  905,  917,  934,  935,  941,  942,  944,  946,  950,  956,  957,
   961,  965,  969,  973,  974,  975,  977,  985,  985,  989,  992,  996, 1000,
  1003, 1007, 1009, 1013, 1017, 1018, 1021, 1022, 1023, 1024, 1025, 1026, 1029,
  1032, 1035, 1036, 1037, 1040, 1045, 1048, 1053, 1058, 1059, 1060, 1061, 1062,
  1063, 1064, 1065, 1066, 1067, 1068, 1069, 1070, 1071, 1072, 1074, 1076, 1080,
  1081, 1089, 1092
};

bool sysTecMode = false;

byte plLadderAnimationStep = 0;
word gfxTileAnimationStepFast = 0;
word gfxTileAnimationStepSlow = 0;

// See UpdateAndDrawEffects() in game2.c
sbyte EFFECT_MOVEMENT_TABLES[][21] = {
  // EM_FLY_LEFT
  {  3,  0,  3,  0,  3,  0,  2,  0,  2,  1,  2,  1,  2,  2,  1,  2,  1,  3,  1,  3, -127 },

  // EM_FLY_UPPER_LEFT
  {  3, -3,  2, -2,  2, -1,  1,  0,  1,  0,  1,  1,  1,  2,  1,  2,  1,  3,  1,  3, -127 },

  // EM_FLY_UP
  {  0, -3,  0, -2,  0, -2,  0, -1,  0,  0,  0,  1,  0,  1,  0,  2,  0,  3,  0,  3, -127 },

  // EM_FLY_UPPER_RIGHT
  { -3, -3, -2, -2, -2, -1, -1,  0, -1,  0, -1,  1, -1,  2, -1,  3, -1,  4, -1,  4, -127 },

  // EM_FLY_RIGHT
  { -3,  0, -3,  0, -3,  0, -2,  0, -2,  1, -2,  1, -2,  2, -1,  3, -1,  3, -1,  3, -127 },

  // EM_FLY_DOWN
  {  0,  1,  0,  2,  0,  2,  0,  2,  0,  3,  0,  3,  0,  3,  0,  3,  0,  3,  0,  3, -127 },

  // EM_BLOW_IN_WIND
  { -2,  1, -2,  1, -2,  1, -1,  1,  0,  1,  1,  1,  2,  0,  1, -1, -2, -1, -2,  1, -127 }
};


byte gmDifficulty = 0;
byte plWeapon = WPN_REGULAR;
byte plAmmo = MAX_AMMO;
byte plHealth = PLAYER_MAX_HEALTH;

// Pairs of (animation frame, Y movement)
sbyte PL_DEATH_ANIMATION[] = { 29, -2, 29, -1, 29, 0, 29, 0, 30, 1, 31, 1 };

bool gmBeaconActivated = false;

#ifdef REGISTERED_VERSION
bool sysCopyProtectionFailed = false;
#endif

char LEVEL_NAMES[5][8][7] = {
  // Episode 1
  {"l1.MNI", "l2.MNI", "l3.MNI", "l4.MNI", "l5.MNI", "l6.MNI", "l7.MNI", "l8.MNI"},

  // Episode 2
  {"m1.MNI", "m2.MNI", "m3.MNI", "m4.MNI", "m5.MNI", "m6.MNI", "m7.MNI", "m8.MNI"},

  // Episode 3
  {"n1.MNI", "n2.MNI", "n3.MNI", "n4.MNI", "n5.MNI", "n6.MNI", "n7.MNI", "n8.MNI"},

  // Episode 4
  {"o1.MNI", "o2.MNI", "o3.MNI", "o4.MNI", "o5.MNI", "o6.MNI", "o7.MNI", "o8.MNI"},

  // Demo
  {"l1.MNI", "l3.MNI", "l5.MNI", "l7.MNI"}
};

// Used to keep track of the most recent selection state for various menus.
// When re-entering a menu later, its selection state can be restored.
byte uiMenuSelectionStates[20] = { 2, 0, };

byte SOUND_PRIORITY[] = {
    1,    // SND_NORMAL_SHOT
    4,    // SND_BIG_EXPLOSION
    3,    // SND_DUKE_PAIN
    5,    // SND_DUKE_DEATH
    2,    // SND_EXPLOSION
    0,    // SND_MENU_SELECT
    2,    // SND_GLASS_BREAKING
    2,    // SND_DUKE_LASER_SHOT
    1,    // SND_ITEM_PICKUP
    2,    // SND_WEAPON_PICKUP
    3,    // SND_ENEMY_HIT
    1,    // SND_SWOOSH
    2,    // SND_FLAMETHROWER_SHOT
    0,    // SND_DUKE_JUMPING
    2,    // SND_LAVA_FOUNTAIN
    0,    // SND_DUKE_LANDING
    1,    // SND_ATTACH_CLIMBABLE
    0,    // SND_MESSAGE_TYPING
    3,    // SND_HAMMER_SMASH
    1,    // SND_ROCK_LANDING
    3,    // SND_ALTERNATE_EXPLOSION
    0,    // SND_WATER_DROP
    1,    // SND_FORCE_FIELD_FIZZLE
    0,    // SND_UNKNOWN1
    2,    // SND_SLIDING_DOOR
    0,    // SND_MENU_TOGGLE
    1,    // SND_FALLING_ROCK
    2,    // SND_ENEMY_LASER_SHOT
    1,    // SND_EARTHQUAKE
    3,    // SND_BIOLOGICAL_ENEMY_DESTROYED
    4,    // SND_TELEPORT
    4,    // SND_UNKNOWN2
    4,    // SND_HEALTH_PICKUP
    4     // SND_LETTERS_COLLECTED_CORRECTLY
};

#ifdef REGISTERED_VERSION
// Reference version of the expected file_id.diz file contents for the copy
// protection check (see main.c).
// '*' characters in the reference string are treated as linebreaks.
static const char EXPECTED_FILE_ID_DIZ[450] =
  "\xDB\xDB\xDB\xDB\xB2\xB1\xB0 ALERT THE SYSOP IMMEDIATELY! \xB0\xB1\xB2\xDB\xDB\xDB\xDB*"
  "\xDB\xDB\xDB\xDB\xDB\xDB\xDB\xDB\xDB\xDB\xDB\xDB\xDB\xDB\xDB\xDB\xDB\xDB\xDB\xDB\xDB\xDB\xDB\xDB\xDB\xDB\xDB\xDB\xDB\xDB\xDB\xDB\xDB\xDB\xDB\xDB\xDB\xDB\xDB\xDB\xDB\xDB\xDB\xDB*"
  "THIS FILE IS NOT SHAREWARE -- it is ILLEGAL*"
  "and forbidden to upload this copyrighted*"
  "software to bulletin boards. If you see this*"
  "message on a BBS, please request that the*"
  "Sysop remove this software IMMEDIATELY!!!*"
  "\xDB\xB2\xB1\xB0 OR CONTACT APOGEE: (214) 278-5655 \xB0\xB1\xB2\xDB*"
  "IT IS ILLEGAL TO GET THIS FILE FROM A BBS!*"
  "\xDB\xDB\xDB\xDB\xDB\xDB\xDB\xDB\xDB\xDB\xDB\xDB\xDB\xDB\xDB\xDB\xDB\xDB\xDB\xDB\xDB\xDB\xDB\xDB\xDB\xDB\xDB\xDB\xDB\xDB\xDB\xDB\xDB\xDB\xDB\xDB\xDB\xDB\xDB\xDB\xDB\xDB\xDB\xDB";
#endif


bool pascal FindPlayerShotInRect(word left, word top, word right, word bottom);
void pascal Map_DestroySection(word left, word top, word right, word bottom);
bool pascal SpawnEffect(word id, word x, word y, word type, word spawnDelay);
void pascal SpawnDestructionEffects(word handle, int* spec, word actorId);
void pascal SpawnBurnEffect(word effectId, word sourceId, word x, word y);
byte pascal ShowScriptedUI(char far* scriptName, char far* filename);
void DamagePlayer(void);
void UpdateAndDrawActors(void);
void UpdateAndDrawPlayerShots(void);
void UpdateAndDrawEffects(void);
void UpdateAndDrawWaterAreas(void);
void UpdateAndDrawTileDebris(void);
void ShowOptionsMenu(void);
void ShowDuke3dTeaserScreen(void);
bool ShowIntroVideo(void);
static void InitSubsystems(void);


/** Write a saved game file to disk
 *
 * The idChar parameter determines the filename.  Uses the current state of
 * various global variables to create the file.
 */
void pascal WriteSavedGame(char idChar)
{
  static char* filename = "NUKEM2.-S ";

  int fd;

  filename[9] = idChar;
  fd = OpenFileW(filename);

  WriteWord(plWeapon, fd);
  WriteWord(plHealth, fd);
  WriteWord(plAmmo, fd);
  WriteWord(gmDifficulty, fd);
  WriteWord(gmCurrentEpisode, fd);
  WriteWord(gmCurrentLevel, fd);
  WriteWord(gmBeaconActivated, fd);

  // [NOTE] Not sure what this is for. It effectively causes these two
  // tutorials to be shown again whenever the game is saved, which seems
  // strange.
  gmTutorialsShown[TUT_RADARS_LEFT] = false;
  gmTutorialsShown[TUT_HINT_MACHINE] = false;

  WriteWord(bdAddressAdjust, fd);
  _write(fd, gmTutorialsShown, NUM_TUTORIAL_IDS);
  _write(fd, &plScore, sizeof(dword));

  CloseFile(fd);
}


/** Load saved game file from disk
 *
 * The idChar parameter determines the filename.  Loads the file and sets the
 * state of various global variables.  Returns true on success, false if the
 * file can't be opened.
 */
bool pascal ReadSavedGame(char idChar)
{
  static char* filename = "NUKEM2.-S ";

  int fd;

  filename[9] = idChar;
  fd = OpenFileRW(filename);

  if (fd == -1)
  {
    return false;
  }

  plWeapon = ReadWord(fd);
  plHealth = ReadWord(fd);

  // When restoring from a beacon (checkpoint), the player is always given at
  // least 2 health, even if they were at 1 when activating the beacon.  In
  // regular saved games, health is always 9 (the maximum), so this code path
  // is never taken there.
  if (plHealth == 1)
  {
    plHealth = 2;
  }

  plAmmo = ReadWord(fd);
  gmDifficulty = ReadWord(fd);
  gmCurrentEpisode = ReadWord(fd);
  gmCurrentLevel = ReadWord(fd);
  gmBeaconActivated = ReadWord(fd);
  bdAddressAdjust = ReadWord(fd);

  // [BUG] Tutorials state shouldn't be changed when respawning from a beacon
  // (checkpoint) - this effectively causes tutorials that the player has
  // triggered after reaching a beacon to be shown again if the player dies and
  // respawns.
  _read(fd, gmTutorialsShown, NUM_TUTORIAL_IDS);

  // When restoring from a beacon, the player keeps their score.
  if (!gmBeaconActivated)
  {
    _read(fd, &plScore, sizeof(dword));
  }

  CloseFile(fd);
  return true;
}


/** Persists current game options to disk */
void WriteOptionsFile(void)
{
  static char* OPTIONS_FILE_NAME = "NUKEM2.-GT";

  int fd = OpenFileW(OPTIONS_FILE_NAME);

  WriteWord(kbBindingUp, fd);
  WriteWord(kbBindingDown, fd);
  WriteWord(kbBindingLeft, fd);
  WriteWord(kbBindingRight, fd);
  WriteWord(kbBindingJump, fd);
  WriteWord(kbBindingFire, fd);

  // [NOTE] The current difficulty is stored in the options file, but the value
  // is never used. Perhaps left over from an earlier point in development.
  WriteWord(gmDifficulty, fd);

  WriteWord(sndUseSbSounds, fd);
  WriteWord(sndUseAdLibSounds, fd);
  WriteWord(sndUsePcSpeakerSounds, fd);
  WriteWord(sndMusicEnabled, fd);

  WriteWord(jsCalibrated, fd);
  WriteWord(jsThresholdRight, fd);
  WriteWord(jsThresholdLeft, fd);
  WriteWord(jsThresholdDown, fd);
  WriteWord(jsThresholdUp, fd);
  WriteWord(jsButtonsSwapped, fd);
  WriteWord(gmSpeedIndex, fd);

  CloseFile(fd);
}


/** Loads game options from disk, or sets defaults if no options file exists */
void ReadOptionsFile(void)
{
  static char* OPTIONS_FILE_NAME = "NUKEM2.-GT";

  int fd = OpenFileRW(OPTIONS_FILE_NAME);

  sndSoundEnabled = true;

  if (fd == -1)
  {
    // No options file found, set up defaults.
    kbBindingUp = SCANCODE_UP;
    kbBindingDown = SCANCODE_DOWN;
    kbBindingLeft = SCANCODE_LEFT;
    kbBindingRight = SCANCODE_RIGHT;
    kbBindingJump = SCANCODE_CTRL;
    kbBindingFire = SCANCODE_ALT;

    gmDifficulty = DIFFICULTY_EASY;
    sndSoundEnabled = true;
    jsCalibrated = false;

    if (SoundBlasterPresent)
    {
      sndUseSbSounds = true;
      sndMusicEnabled = true;
    }
    else if (AdLibPresent)
    {
      sndUseAdLibSounds = true;
      sndMusicEnabled = true;
    }
    else
    {
      sndUsePcSpeakerSounds = true;
    }

    gmSpeedIndex = 4;

    // Pre-select default game speed in the game speed menu, by setting the
    // scripting system's per-menu selection state
    uiMenuSelectionStates[MT_GAME_SPEED] = 4;

    jsButtonsSwapped = false;
  }
  else // options file found
  {
    kbBindingUp = ReadWord(fd);
    kbBindingDown = ReadWord(fd);
    kbBindingLeft = ReadWord(fd);
    kbBindingRight = ReadWord(fd);
    kbBindingJump = ReadWord(fd);
    kbBindingFire = ReadWord(fd);

    // [NOTE] Also see note in WriteOptionsFile. The difficulty is read from the
    // options file here, but the value isn't used. Starting a new game will
    // overwrite it with the difficulty selected in the menu (which always
    // defaults to 'medium').  Loading a saved game overwrites it with what's
    // stored in the save file.
    gmDifficulty = ReadWord(fd);

    sndUseSbSounds = ReadWord(fd);
    sndUseAdLibSounds = ReadWord(fd);
    sndUsePcSpeakerSounds = ReadWord(fd);
    sndMusicEnabled = ReadWord(fd);

    jsCalibrated = ReadWord(fd);
    jsThresholdRight = ReadWord(fd);
    jsThresholdLeft = ReadWord(fd);
    jsThresholdDown = ReadWord(fd);
    jsThresholdUp = ReadWord(fd);
    jsButtonsSwapped = ReadWord(fd);
    gmSpeedIndex = ReadWord(fd);

    // Pre-select stored game speed in the game speed menu, by setting the
    // scripting system's per-menu selection state
    uiMenuSelectionStates[MT_GAME_SPEED] = gmSpeedIndex;

    CloseFile(fd);
  }
}


#include "sound.c"


/** Stop music and deallocate pre-boss music data
 *
 * See AdjustMusicForBossLevel().
 */
void StopPreBossMusic(void)
{
  sndCurrentMusicFileSize = sndOriginalMusicSize;
  StopMusic();
  MM_PopChunk(CT_TEMPORARY);
}


/** Replace level-specific music with pre-boss music
 *
 * If the current level is a boss level, i.e. last level of an episode, a
 * "pre-boss" song is played instead of the level-specific song. As soon as the
 * boss is sighted, music playback switches over to the regular song.
 */
void AdjustMusicForBossLevel(void)
{
  if (!AdLibPresent || gmCurrentLevel != 7) { return; }

  sndOriginalMusicSize = sndCurrentMusicFileSize;

  sndCurrentMusicFileSize = GetAssetFileSize("CALM.IMF");

  sndPreBossMusicData = MM_PushChunk(sndCurrentMusicFileSize, CT_TEMPORARY);
  LoadAssetFile("CALM.IMF", sndPreBossMusicData);
  StartMusicPlayback(sndPreBossMusicData);
}


/** Returns 1, 0, or -1 depending on val's sign/value */
int Sign(int val)
{
  if (val < 0)
  {
    return -1;
  }
  else if (val > 0)
  {
    return 1;
  }

  return 0;
}


/** Replacement for C library's abs */
int DN2_abs(int val)
{
  if (val < 0)
  {
    return -val;
  }

  return val;
}


#include "hud3.c"


/** Get value of map tile at given location */
word Map_GetTile(word x, word y)
{
  if ((int)y < 0)
  {
    return 0;
  }

  return *(mapData + x + (y << mapWidthShift));
}


/** Set value of map tile at given location */
void Map_SetTile(word tileIndex, word x, word y)
{
  *(mapData + x + (y << mapWidthShift)) = tileIndex;
}


#include "game1.c"
#include "sprite.c"
#include "game2.c"
#include "game3.c"
#include "script2.c"
#include "main.c"
